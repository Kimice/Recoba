### 一致性hash

** 需要解决的问题 ** 

	场景:有N个cache服务器,需要将object映射到某台机器上.普通的hash算法,映射公式为value = hash(key)%N,
	但当有一台机器down掉后,映射公式变为hash(key)%(N-1),所有机器的映射关系都为改变,导致cache全部失效.

** 算法设计 **

0. 单调性:
    
	    采用环形存储的思路,N台服务器分布在环上的各个位置.
	    通过之前的公式,计算出哈希值h,h代表object在环上的位置,然后沿顺时针方向行走,直到遇到服务器为止.

0. 容错性,可扩展性:

        某台机器down掉时,本属于该机器的object都会顺延到下一个机器;
        新增一台机器时,下一台机器的部分object会被新机器截断.

0. 负载均衡:

        当机器很少时,可能会遇到分布不均的情况.采用`虚拟节点`的方式,为仅存的机器在环上虚拟出N倍的机器分身,
        映射到虚拟分身的object实际访问的还是对应本体机器.


### Quorum机制

** 需要解决的问题 **

    分布式系统中,会遇到一系列数据可靠性和一致性的问题.最简单的读写机制就是Read Only Write All.
    但是这样,要求每次数据update,每份数据都会全部更新,写的压力很大.
    需要一个机制,保证每次读到的数据是最新的,但读写压力可控.
    
** 机制原理 **

0. 抽屉原理:
    
        假设有两个抽屉,分别放了两个红苹果和两个青苹果.现在去出三个苹果,肯定有一个红苹果.
        这里的抽屉可以理解为机器节点,苹果代表数据.
   
0. 实现逻辑:
    
        假设有N份数据副本,其中有K份已经更新了,未更新的数量为N-K,
        那么当我们去N-K+1份数据的时候,肯定有一份数据是最新的.
        我们只要从中,取出数据版本最新的一份即可.
        这种方式增加的Read的成本.但大大减小了Write的成本.
    

### Bloom Filter

** 需要解决的问题 **

        处理大规模的数据集中,查询数据
    
** 机制原理 **
 
 0. 实现方式:
 
        创建一个m位的BitSet,所有位初始值为0.
        同时拥有k个hash函数,每次插入都会在BitSet的每个对应位置都置1.
        假设查询一个字符串str,分别计算k次hash函数,如果对于的BitSet都为1时,
        该str可能存在,而不全为1的时候,肯定不存在.
        str删除存在问题,会影响其余数据.可以参考CBF算法.
        
        
        